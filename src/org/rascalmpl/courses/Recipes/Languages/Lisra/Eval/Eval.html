<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">

<!---- DO NOT EDIT: HTML generated by CourseCompiler ---->


<head>
<title>Recipes/Languages/Lisra/Eval</title>

<meta name="description" content="Recipes/Languages/Lisra/Eval:  A Lisp interpreter.">

<meta name="keywords" content="Recipes/Languages/Lisra/Eval, Rascal, meta-programming, software analysis, software transformation">
<link type="text/css" rel="stylesheet" href="/prelude.css"/>
<link type="text/css" rel="stylesheet" href="/jquery.autocomplete.css"/>
<script type="text/javascript" src="/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="/jquery.colorbox-min.js"></script>
<script type="text/javascript" src="/jquery.cookie.js"></script>
<script type="text/javascript" src="/jquery.jstree.js"></script>
<script type="text/javascript" src="/jquery.autocomplete.js"></script>
<script type="text/javascript" src="/jquery.history.js"></script>
<script type="text/javascript" src="/globals.js"></script>
<script type="text/javascript" src="/prelude.js"></script>
<script type="text/javascript" src="/Recipes/course.js"></script>

</head>
<body>
<table id="container"><tr><td id="tdlogo"><a id="tutorAction" href="/index.html"><img id="leftIcon" height="40" width="40" src="/images/rascal-tutor-small.png"></a></td><td id="tdsearch">
<div id="searchBox">
  <form method="GET" id="searchForm" action="/search"> 
    <img id="searchIcon" height="20" width="20" src="/images/magnify.png">
    <input type="hidden" name="concept" value="Recipes/Languages/Lisra/Eval">
    <input type="text" id="searchField" name="term" autocomplete="off"><br />
    <div id="popups"></div>
  </form>
</div>
         </td></tr><tr><td id="tdnav">
<a id="navPanePlaceHolder" href="/Recipes/navigate.html" >Navigation</a>
<script type="text/javascript"> var navigationPaneSource="/Recipes/navigate.html"; </script></td><td id="tdconcept">
<div id="conceptPane">

<div id="Name">
<span class="sectionHead">Name</span> <a href="/Recipes/Recipes.html">Recipes</a>/<a href="/Recipes/Languages/Languages.html">Languages</a>/<a href="/Recipes/Languages/Lisra/Lisra.html">Lisra</a>/<a href="/Recipes/Languages/Lisra/Eval/Eval.html">Eval</a>
</div>

<div id="Synopsis">
<span class="sectionHead">Synopsis</span>  A Lisp interpreter.

</div>

	                       
                           
                           
                           
<div id="Description">
<span class="sectionHead">Description</span>  Here is the core of our Lisp interpreter. Its basic functionality is to take
 <ul><li> An <code>Lval</code> and an Environment (both defined in <a href="/Recipes/Languages/Lisra/Runtime/Runtime.html">Runtime</a>).</li>
<li> Distinguish the various forms an <code>Lval</code> can have and compute the   effect of evaluating it.
</li>
<li> Return a <code>Result</code> that captures the value just computed and possibleside-effects on the environment.
</li>
</ul> Rascal provides pattern-directed dispatch: a function with the same name
 can have complete patterns as arguments. When called, a pattern match determines which
 variant of the function will be called. This is used extensively in the definitions below:
  <pre class="listing">module demo::lang::Lisra::Eval

import Prelude;
import demo::lang::Lisra::Runtime;

public Lval eval(Lval x) = eval(x, [()]).val;

// Evaluate an Lval in a given environment and return a Result.

public Result eval(Integer(int x), Env e) = &lt;Integer(x), e>; <img src="/images/1.png">

public Result eval(var:Atom(str name), Env e) {              <img src="/images/2.png">
  n = find(var, e);
  return &lt;(n &lt; 0) ? var : e[n][var], e>;
}

public Result eval(List([Atom("quote"), exp*]), Env e) =     <img src="/images/3.png">
  &lt;size(exp) == 1 ? exp[0] : List(exp), e>;

public Result eval(List([Atom("set!"), var, exp]), Env e) {  <img src="/images/4.png">
  val = eval(exp, e).val;
  n = find(var, e);
  if(n &lt; 0) e[0][var] = val; else e[n][var] = val;
  return &lt;val, e>;
}
                                                             <img src="/images/5.png">
public Result eval(List([Atom("if"), Lval tst, Lval conseq, Lval alt]), Env e) = 
       eval(tst, e).val != FALSE ? eval(conseq, e) : eval(alt, e);
       
                                                             <img src="/images/6.png">
public Result eval(List([Atom("begin"), *Lval exps]) , Env e) {
  val = FALSE;
  for(Lval exp &lt;- exps){
      &lt;val, e> = eval(exp, e);
  }
  return &lt;val, e>;
}
                                                             <img src="/images/7.png">
public Result eval(List([Atom("define"), var, exp]), Env e){
   e[0][var] = eval(exp, e).val;
   return &lt;FALSE, e>;
}
                                                             <img src="/images/8.png">
public Result eval(List([Atom("lambda"), List(vars*), exp]), Env defEnv) =
  &lt;Closure(Result(list[Lval] args, Env callEnv) { return eval(exp, makeEnv(vars, args, tail(callEnv, size(defEnv))));}),
   defEnv>;

public default Result eval(List([ exps* ]), Env e) {         <img src="/images/9.png">
  if(isEmpty(exps))
     return &lt;FALSE, e>;
  vals = [ eval(exp, e).val | exp &lt;- exps ];
  return apply(head(vals), tail(vals), e);
}

//public default Result eval(Lval exp, Env e) = &lt;exp, e>;

                                                             <img src="/images/10.png">
// Apply an Lval to a list of arguments and return a Result
public Result apply(Closure(Result(list[Lval] args, Env env) fn), list[Lval] args, Env e) {
  return &lt;fn(args, e).val, e>;
}
                                                             <img src="/images/11.png">

public Result apply(Atom("+"),      [Integer(x), Integer(y)], Env e) = &lt;Integer(x + y), e>;
public Result apply(Atom("-"),      [Integer(x), Integer(y)], Env e) = &lt;Integer(x - y), e>;
public Result apply(Atom("*"),      [Integer(x), Integer(y)], Env e) = &lt;Integer(x * y), e>;
public Result apply(Atom("\&lt;"),     [x, y],                   Env e) = &lt;x &lt; y ? TRUE : FALSE, e>;
public Result apply(Atom("\>"),     [x, y],                   Env e) = &lt;x >= y ? TRUE : FALSE, e>;
public Result apply(Atom("equal?"), [x, y],                   Env e) = &lt;x == y ? TRUE : FALSE, e>;
public Result apply(Atom("null?"),  [List(*x)],               Env e) = &lt;isEmpty(x) ? TRUE : FALSE, e>;
public Result apply(Atom("cons"),   [x, List(y*)],            Env e) = &lt;List([x, *y]), e>;
public Result apply(Atom("append"), [List(x*), y],            Env e) = &lt;List([*x, *y]), e>;
public Result apply(Atom("car"),    [List(x*)],               Env e) = &lt;head(x), e>;
public Result apply(Atom("cdr"),    [List(x*)],               Env e) = &lt;List(tail(x)), e>;
public Result apply(Atom("list"),   list[Lval] x,             Env e) = &lt;List(x), e>;

default Result apply(Lval a,     list[Lval] b, Env e) {      <img src="/images/12.png">
  println("Cannot apply &lt;a> to &lt;b> using &lt;e>");
  return &lt;FALSE, e>;
}
</pre> We now explain the different cases in more detail:
  <ul><li> <img src="/images/1.png"> An integer constant evaluates to itself. Note how <code>Integer(int x)</code> is used as first   argument of this <code>eval</code> function. It is a pattern that describes that the constructor <code>Integer</code>
   with an <code>int</code> argument <code>x</code> is to be matched.
</li>
<li> <img src="/images/2.png"> An atom evaluates to the value to which it is bound or to itself. <code>find</code> (see <a href="/Recipes/Languages/Lisra/Runtime/Runtime.html">Runtime</a>) is used   to search for the atom in question. The first argument is <code>var:Atom(str name)</code>, a pattern that matches
   an <code>Atom</code>. The <code>var:</code> prefix binds the complete atom to a variable <code>var</code> to be used in the body of the function.
</li>
<li> <img src="/images/3.png"> A quoted list evaluates to itself. The pattern <code>List([Atom("quote"), exp*])</code> matches a <code>List</code> constructor   whose first element is <code>Atom("quote")</code>. <code>exp*</code> means that the remaining list elements are assignment to <code>exp</code>.
   There are two cases: if the argument list has size 1, its first element is used, otherwise a list with all elements of <code>exp</code>
   vare returned. This ensures that <code>List([Atom("quote"), Integer(17)])</code> evaluates to  <code>Integer(17)</code> and not to <code>List([ Integer(17)]</code>.
</li>
<li> <img src="/images/4.png"> Evaluates a <code>set!</code> expression that assigns the value of <code>exp</code> to variable <code>var</code>.</li>
<li> <img src="/images/5.png"> Evaluates the <code>if</code> expression. The test <code>tst</code> is evaluated and is not false, the value of <code>conseq</code> is returned and otherwise   that of <code>alt</code>.
</li>
<li> <img src="/images/6.png"> Evaluates a <code>block</code> expression. The list of expressions <code>exps</code> is evaluated one by one. Observe that in the for loop   <code>&lt;val, e> = eval(exp, e);</code> captures both the value and the environment that results from executing one expression. That new environment is
   is used to evaluate the next expression(s) in the list. The value of the last expression and a possible modied environment are returned.
</li>
<li> <img src="/images/7.png"> Evaluate a <code>define</code> expression that binds the value of <code>exp</code> to variable <code>var</code>.   The value of the expression is bound <code>var</code> in the local scope.
</li>
<li> <img src="/images/8.png"> Evaluate a lambda expression. Essentially we return a <code>Closure</code> value that contains the expression in the lambda expression   properly wrapped to do variable binding and environment management. 
    A Closure contains a function that return type <code>Results</code> and has two arguments:
    <code>list[lval] args</code> the actual parameter values when the closure is applied, and
    <code>Env e</code> the environment at the site of the call.
      In the body of the closure we construct a new environment <code>makeEnv(vars, args, tail(callEnv, size(defEnv)))</code> that binds the variables
      in the lambda expression to the actual parameter values. What is special here is that we shorten the calling environment to the
      same length as the defining environment. This implements <i>lexical scoping</i> and avoids that names are visible in the called
      function that were not visible when the function was defined. Remember that Rascal values are immutable, meaning that after a value was 
      created it cannot be changed. Using the above trick, we ensure that the called function has access to the most recent version of
      its environment.
</li>
<li> <img src="/images/9.png"> Evaluates an arbitrary list. As a special case, the empty list is returned as false.   Otherwise, all elements are evaluated and the auxiliary function <code> apply</code> is used to apply the value of the first element to the values of   
   the remaining elements.
</li>
<li> <img src="/images/10.png"> Apply an <code>Lval</code> to a list of arguments and return a <code>Result</code>. The first case handles a <code>Closure</code>; it amounts   to calling the function in the closure (environment handling and parameter binding are done in the closure as discussed above (<img src="/images/8.png">).
</li>
<li> <img src="/images/11.png"> Definition of all built-in functions.</li>
<li> <img src="/images/12.png"> A default function that prints an error message when an undefined function is called.</li>
</ul>
</div>

  	                       
<div id="Examples">
<span class="sectionHead">Examples</span>  <pre class="screen"><span class="prompt">rascal></span>import demo::lang::Lisra::Runtime;
ok
<span class="prompt">rascal></span>import demo::lang::Lisra::Eval;
ok
<span class="prompt">rascal></span>eval(Integer(5));
Lval: Integer(5)
<span class="prompt">rascal></span>eval(Atom(&quot;x&quot;));
Lval: Atom("x")
<span class="prompt">rascal></span>eval(List([Atom(&quot;+&quot;), Integer(5), Integer(7)]));
Lval: Integer(12)
</pre>
</div>

  	                       
<div id="Benefits">
<span class="sectionHead">Benefits</span>  <ul><li> A very modular, rule-based, type safe Lisp interpreter.</li>
</ul>
</div>

  	                       
<div id="Pitfalls">
<span class="sectionHead">Pitfalls</span>  <ul><li> It is no pleasure to type in <code>Lval</code>s directly, that is why a parser is needed (<a href="/Recipes/Languages/Lisra/Parse/Parse.html">Parse</a>).</li>
</ul>
</div>

  	                       
<a id="tutorAction" href="/index.html"><img id="leftIcon" height="40" width="40" src="/images/rascal-tutor-small.png"></a><div id="editMenu">[<a id="editAction" href="/edit?concept=Recipes/Languages/Lisra/Eval&new=false"><b>Edit</b></a>] | 
               [<a id="newAction" href="/edit?concept=Recipes/Languages/Lisra/Eval&new=true"><b>New Subconcept</b></a>] |
               [<a id="compileAction" href="/compile?name=Recipes"><b>Recompile Course</b></a>] |
               [<a id="warnAction" href="/Recipes/warnings.html"><b>Warnings</b></a>]</div>
<span class="editMenuFooter">Is this page unclear, or have you spotted an error? Please add a comment below and help us to improve it. For all other questions and remarks, visit <a href="http://ask.rascal-mpl.org">ask.rascal-mpl.org</a>. </span>
</div>
</td></tr></table>
</body>
</html>